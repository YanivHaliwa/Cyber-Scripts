#!/usr/bin/env python3
import os
import sys
import argparse
import subprocess
import requests
import json
from bs4 import BeautifulSoup
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
import tempfile


try:
    from attackerkb_api import AttackerKB
except ImportError:
    print("Error: AttackKB Python client not installed. Run 'pip install attackerkb-api'", file=sys.stderr)
    sys.exit(1)

# Color settings for output
COLORS = {
    'number': '\033[94m',  # Blue
    'searchsploit': '\033[92m',  # Green
    'nvd': '\033[93m',  # Yellow
    'attackerkb': '\033[95m',  # Magenta
    'msfconsole': '\033[96m',  # Cyan
    'reset': '\033[0m',  # Reset to default color
    'alert': '\033[91m',  # Red for errors
    'info': '\033[97m'   # White for info/status
}

# Search local exploitdb via searchsploit
def search_searchsploit(query):
    try:
        result = subprocess.check_output(['searchsploit', '--json', query], stderr=subprocess.DEVNULL)
        data = json.loads(result.decode('utf-8'))
        entries = data.get('RESULTS_EXPLOIT', [])
        exploits = []
        for item in entries:
            exploits.append({
                'source': 'searchsploit',
                'title': item.get('Title'),
                'platform': item.get('Platform'),
                'link': item.get('Path')
            })
        return exploits
    except Exception:
        return []

# Search NVD for CVEs
def search_nvd(query):
    url = f'https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={query}'
    headers = {'User-Agent': 'exploit-search-script'}
    exploits = []
    try:
        resp = requests.get(url, headers=headers, timeout=10)
        resp.raise_for_status()
        data = resp.json()
        for item in data.get('vulnerabilities', []):
            cve = item.get('cve', {})
            descs = cve.get('descriptions', [])
            title = descs[0].get('value') if descs else cve.get('id')
            cve_id = cve.get('id')
            link = f'https://nvd.nist.gov/vuln/detail/{cve_id}'
            exploits.append({
                'source': 'nvd',
                'title': title,
                'platform': 'N/A',
                'link': link
            })
    except Exception:
        pass
    return exploits

# Search AttackKB via official Python client
# Get AttackerKB API key from environment variables
ATTACKERKB_API_KEY = os.environ.get('ATTACKERKB_API_KEY')
def search_attackerkb(query):
    api = AttackerKB(ATTACKERKB_API_KEY)
    exploits = []
    try:
        topics = api.get_topics(name=query)
    except Exception as e:
        print(f"Warning: AttackKB client error: {e}", file=sys.stderr)
        return exploits
    for topic in topics:
        title = topic.get('name')
        tid = topic.get('id')
        link = f'https://attackerkb.com/topics/{tid}'
        exploits.append({
            'source': 'attackerkb',
            'title': title,
            'platform': 'N/A',
            'link': link
        })
    return exploits

# Search Metasploit modules via msfconsole
def search_msfconsole(query):
    exploits = []
    try:
        # Parse the query to create more advanced searches
        # Look for version numbers like 1.8 to use with CVE searches
        version_match = re.search(r'(\d+\.\d+(?:\.\d+)?)', query)
        # search across all fields (module name or description) for the query
        search_cmd = f"search {query} type:exploit"
        
        # If we have a product name and version number, create a more targeted search
        if version_match:
            version = version_match.group(1)
            # Extract product name (text before version number)
            product_parts = query.split(version)[0].strip().split()
            if product_parts:
                product = product_parts[-1].lower()  # Last word before version
                # Create a targeted search that includes the version number
                search_cmd = f"search {product} type:exploit"
                
                # # Debug info about the search to show the user
                # print(f"{COLORS['info']}Searching for exploits related to: {product} (with version filtering){COLORS['reset']}")
                
                # Filter results post-query by examining descriptions for version match
                def version_filter(item):
                    # Check if the version appears in title or description
                    return version in item.get('title', '') or f"v{version}" in item.get('title', '')
                
                # Set this function to use later
                post_filter = version_filter
            else:
                post_filter = None
        else:
            post_filter = None
        
        out = subprocess.check_output(
            ['msfconsole', '-q', '-x', f"{search_cmd}; exit"], stderr=subprocess.DEVNULL
        )
        for line in out.decode('utf-8', errors='ignore').splitlines():
            if re.match(r'^\s*\d+', line):
                parts = re.split(r'\s{2,}', line.strip())
                if len(parts) >= 3:
                    module = parts[1]
                    # skip entries that are not actual modules (no slash)
                    if '/' not in module:
                        continue
                    desc = parts[-1]
                    # skip entries with just punctuation or orphan targets
                    if desc.strip() == '.' or desc.strip().startswith('_'):
                        continue
                    plat = module.split('/')[1] if '/' in module else 'N/A'
                    item = {
                         'source': 'msfconsole',
                         'title': desc,
                         'platform': plat,
                         'link': module
                    }
                    exploits.append(item)
        
        # Apply post-filtering if we have a version filter
        if post_filter:
            # First try to get exact version matches
            filtered = [item for item in exploits if post_filter(item)]

            # If we have exact matches, use them; otherwise return all results
            if filtered:
                print(f"{COLORS['info']}Found {len(filtered)} exploits specifically for version {version}{COLORS['reset']}")
                return filtered
            else:
                print(f"{COLORS['info']}No exact version matches for {version}, showing all related exploits{COLORS['reset']}")
        # Now filter by primary term (first word of query) to remove unrelated modules
        primary = query.split()[0].lower()
        filtered_primary = [item for item in exploits
                           if primary in item['link'].split('/')[-1].lower()
                           or primary in item['title'].lower()]
        if filtered_primary:
            return filtered_primary
         
    except Exception as e:
        print(f"Error in MSF search: {e}", file=sys.stderr)
        pass
    return exploits

# Main application
def main():
    from argparse import RawTextHelpFormatter
    parser = argparse.ArgumentParser(
        prog='exploit_search',
        usage='exploit_search [options] query',
        description="""
Unified CLI to search exploits across multiple sources:
  - searchsploit : local Exploit-DB (exploitdb)
  - msfconsole   : Metasploit modules
  - attackerkb   : AttackKB vulnerability topics
  - nvd          : NVD CVEs

Default (no flags) runs searchsploit, attackerkb, and msfconsole.
""",
        formatter_class=RawTextHelpFormatter,
        epilog="""
Examples:
  exploit_search sudo                    # default: search local db, AttackKB, Metasploit
  exploit_search apache -m -n            # search apache in msfconsole and NVD only
  exploit_search mysql --everything      # search mysql across all sources
  exploit_search 'wordpress 5.4' -s      # Exploit-DB search for WordPress 5.4
"""
    )
    # source flags
    parser.add_argument('-s', '--searchsploit', action='store_true', help='include Exploit-DB results (searchsploit)')
    parser.add_argument('-m', '--msf', action='store_true', help='include Metasploit module results')
    parser.add_argument('-a', '--attackerkb', action='store_true', help='include AttackKB topic results')
    parser.add_argument('-n', '--nvd', action='store_true', help='include NVD CVE results')
    parser.add_argument('-e', '--everything', action='store_true', help='include all sources')
    # positional
    parser.add_argument('query', help='search term; wrap in quotes for multi-word queries')

    args = parser.parse_args()
    query = args.query
    # Map source names to search functions
    search_funcs = {
        'searchsploit': search_searchsploit,
        'nvd': search_nvd,
        'attackerkb': search_attackerkb,
        'msfconsole': search_msfconsole
    }
    # Determine which sources to run
    if args.everything:
        sources = list(search_funcs.keys())
    else:
        sources = []
        if args.searchsploit:
            sources.append('searchsploit')
        if args.nvd:
            sources.append('nvd')
        if args.attackerkb:
            sources.append('attackerkb')
        if args.msf:
            sources.append('msfconsole')
    if not sources:
        # default exclude NVD
        sources = ['searchsploit', 'attackerkb', 'msfconsole']
    # Notify user that searches are starting
    print(f"{COLORS['info']}Searching exploits across: {', '.join(sources)}...{COLORS['reset']}")
    # Perform source searches in parallel
    results_raw = []
    with ThreadPoolExecutor(max_workers=len(sources)) as executor:
        future_to_src = {executor.submit(search_funcs[src], query): src for src in sources}
        for future in as_completed(future_to_src):
            src = future_to_src[future]
            try:
                items = future.result() or []
                results_raw.extend(items)
            except Exception:
                print(f"Warning: {src} search failed", file=sys.stderr)

    # Deduplicate by (source, link)
    seen = set()
    results = []
    for item in results_raw:
        key = (item['source'], item['link'])
        if key not in seen:
            seen.add(key)
            results.append(item)

    if not results:
        print('No exploits found.')
        sys.exit(0)

    # Print colored results
    for idx, item in enumerate(results, 1):
        # Add a blank line between different source types
        if idx > 1 and item['source'] != results[idx-2]['source']:
            print("")  # Empty line between different sources
            
        num = f"{COLORS['number']}{idx}.{COLORS['reset']}"
        tag = f"{COLORS[item['source']]}[{item['source']}]{COLORS['reset']}"
        print(f"{num} {tag} {item['title']} - {item['link']}")

    # Unified action prompt: copy, load MSF, or open URL
    import webbrowser
    if results:
        while True:
            try:
                choice = input('\nSelect number to act on (copy/searchsploit, load/MSF, open/URL) or press Enter to exit: ').strip()
                if not choice:
                    break
                num = int(choice)
                selected = results[num-1]
                src = selected['link']
                if selected['source'] == 'searchsploit':
                    title = selected['title']
                    slug = re.sub(r'[^A-Za-z0-9]+', '.', title).strip('.')
                    ext = os.path.splitext(src)[1]
                    dst_name = f"{slug}{ext}"
                    dst_path = os.path.join(os.getcwd(), dst_name)
                    subprocess.run(['cp', src, dst_path])
                    print(f"Copied exploit to {dst_path}")
                elif selected['source'] == 'msfconsole':
                    module = selected['link']
                    print(f"Launching msfconsole and loading module {module}...")
                    # Create temporary resource file with 'use' command only
                    rc = tempfile.NamedTemporaryFile('w', delete=False, suffix='.rc')
                    rc.write(f'use {module}\n')
                    rc.flush()
                    rc.close()
                    # Exec msfconsole with the resource file
                    os.execvp('msfconsole', ['msfconsole', '-r', rc.name])
                else:
                    print(f"Opening URL: {src}")
                    webbrowser.open(src)
                break
            except KeyboardInterrupt:
                print("\nExiting...")
                sys.exit(0)
            except (IndexError, ValueError):
                print(f"{COLORS['info']}Invalid selection, please enter a valid number.{COLORS['reset']}", file=sys.stderr)
            except Exception as e:
                print(f"Error processing selection: {e}", file=sys.stderr)

    # Exit after optional action
    sys.exit(0)

if __name__ == '__main__':
    main()
